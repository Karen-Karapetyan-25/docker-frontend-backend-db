name: build-scan-push-provision

on:
  push:
    branches: [ master ]
  workflow_dispatch:

# ─── Global defaults ──────────────────────────────────────────────────
env:
  # ECR / image-build region
  AWS_REGION: eu-west-1
  # Terraform / EC2 region (must match what you want in main.tf)
  TF_AWS_REGION: eu-west-1

jobs:
  build_and_provision:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write       # needed by configure-aws-credentials OIDC

    steps:
    # ─── Pull the repo ────────────────────────────────────────────────
    - uses: actions/checkout@v4

    # ─── AWS creds for the ECR region (eu-west-1) ─────────────────────
    - name: Configure AWS credentials (eu-west-1)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region:            ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2

    # ─── Build & tag Docker images ────────────────────────────────────
    - name: Set image tags
      id: vars
      run: |
        SHA="${GITHUB_SHA::7}"
        echo "front=383313560305.dkr.ecr.${AWS_REGION}.amazonaws.com/frontend:${SHA}" >> "$GITHUB_OUTPUT"
        echo "back=383313560305.dkr.ecr.${AWS_REGION}.amazonaws.com/backend:${SHA}"  >> "$GITHUB_OUTPUT"

    - name: Build frontend image
      run: docker build -t ${{ steps.vars.outputs.front }} ./frontend

    - name: Build backend image
      run: docker build -t ${{ steps.vars.outputs.back }} ./backend

    # ─── Trivy scans (non-blocking) ───────────────────────────────────
    - name: Scan frontend with Trivy
      uses: aquasecurity/trivy-action@0.19.0
      with:
        image-ref:      ${{ steps.vars.outputs.front }}
        exit-code:      0           # never fail the build
        ignore-unfixed: true

    - name: Scan backend with Trivy
      uses: aquasecurity/trivy-action@0.19.0
      with:
        image-ref:      ${{ steps.vars.outputs.back }}
        exit-code:      0
        ignore-unfixed: true

    # ─── Push to ECR ──────────────────────────────────────────────────
    - name: Push images to ECR
      run: |
        docker push ${{ steps.vars.outputs.front }}
        docker push ${{ steps.vars.outputs.back }}

    # ─── Set up Terraform CLI (1.8.5) ─────────────────────────────────
    - uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.8.5

    # ─── Terraform init/apply in infra/, using eu-central-1 ──────────
    - name: Terraform init
      run: terraform -chdir=Terraform init
      env:
        AWS_REGION:          ${{ env.TF_AWS_REGION }}
        AWS_DEFAULT_REGION:  ${{ env.TF_AWS_REGION }}

    - name: Import IAM role if it already exists
      run: |
        set -e
        cd Terraform
        terraform state show aws_iam_role.ec2_ecr_readonly >/dev/null 2>&1 || \
          terraform import aws_iam_role.ec2_ecr_readonly ec2-ecr-readonly-role
        terraform state show aws_iam_instance_profile.ec2_profile >/dev/null 2>&1 || \
          terraform import aws_iam_instance_profile.ec2_profile ec2-ecr-readonly-profile

# ─── Find runner IP & export TF_VAR_ssh_cidr ───────────────────────────
    # - name: Set SSH CIDR for this runner
    #   id: ip
    #   run: |
    #     MYIP=$(curl -s https://api.ipify.org)
    #     echo "TF_VAR_ssh_cidr=${MYIP}/32" >> $GITHUB_ENV
    #     echo "Using SSH CIDR ${MYIP}/32"


    # ─── Terraform apply ────────────────────────────────────────────────
    - name: Terraform apply
      run: terraform -chdir=Terraform apply -auto-approve
      env:
        AWS_REGION:         ${{ env.TF_AWS_REGION }}
        AWS_DEFAULT_REGION: ${{ env.TF_AWS_REGION }}

    - name: Debug Terraform IP output
      run: |
        echo "IP from Terraform: $(terraform -chdir=Terraform output -raw ec2_public_ip)"

    # ─── Grab the IP from terraform output and build inventory ───────────
    - name: Get EC2 IP & create inventory
      id: inventory
      run: |
        set -e
        IP=$(terraform -chdir=Terraform output -raw ec2_public_ip 2>/dev/null | tr -d '\n')
        echo "ip=$IP" >> "$GITHUB_OUTPUT"
    
        mkdir -p ansible
        cat > ansible/inventory.ini <<EOF
        [app_host]
        $IP ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/ec2_key
        EOF
 
      
        
    - name: Write SSH private key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key

       # (…everything up to SSH key write stays the same …)

    # ─── Write dynamic inventory file ──────────────────────────────────
    - name: Create Ansible inventory
      run: |
        mkdir -p ansible            # workspace already in repo root
        sed "s|<IP>|${{ steps.ec2ip.outputs.ip }}|" \
            ansible/inventory_template.ini \
            > ansible/inventory.ini

    # ─── Install Ansible ───────────────────────────────────────────────
    - name: Install Ansible
      run: |
        sudo apt-get update -y
        sudo apt-get install -y ansible

    # ─── Run playbook: Docker + Compose ────────────────────────────────
    - name: Provision instance with Ansible
      run: |
        export ANSIBLE_HOST_KEY_CHECKING=False
        ansible-playbook \
          -i ansible/inventory.ini \
          ansible/install_docker.yml
  